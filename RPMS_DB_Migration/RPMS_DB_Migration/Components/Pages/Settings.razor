@* 
PSEUDOCODE / DETAILED PLAN:
- Goal: ensure appsettings.json connection string defaults appear in the UI before the page is displayed
  and the "Load from appsettings.json" button does not clear user inputs when a particular config key is missing.
- Steps:
  1) On component initialization (OnInitialized / OnInitializedAsync) read server configuration ConnectionStrings
     for "AccessFile" and "SqlServer" and populate `model` with those values as defaults. This runs before first render,
     so values are visible immediately.
  2) OnAfterRenderAsync(firstRender) still attempt to load persisted settings from browser localStorage (JS interop).
     If localStorage contains saved settings, override the model with those saved values (user persisted choices).
  3) Implement `LoadFromServerConfigAsync` to load server defaults but only overwrite model properties when the config
     value is non-empty — do not clobber existing user-entered values when a config key is absent.
  4) Keep Save, Load, Reset behaviors and clear status messages appropriately.
- Safety/UX:
  - Validate basic input on save.
  - Show clear status messages indicating whether values came from server defaults or browser storage.
*@

@page "/settings"
@using System.Text.Json
@using Microsoft.Extensions.Configuration
@inject IJSRuntime JS
@inject IConfiguration Configuration

<h1>Settings</h1>

<p>
    Set the Access MDB/ACCDB file path and SQL Server connection string. These values are saved to your browser's local storage so they persist across sessions on this browser.
</p>

<EditForm Model="model" OnValidSubmit="SaveAsync">
    <div class="mb-3">
        <label class="form-label">Access file path (MDB/ACCDB)</label>
        <InputText class="form-control" @bind-Value="model.AccessFilePath" />
        <div class="form-text">Example: C:\Data\MyDatabase.mdb</div>
    </div>

    <div class="mb-3">
        <label class="form-label">SQL Server connection string</label>
        <InputTextArea class="form-control" @bind-Value="model.SqlServerConnectionString" rows="4" />
        <div class="form-text">Example: Server=.;Database=MyDb;User Id=sa;Password=...;</div>
    </div>

    <div class="d-flex gap-2">
        <button type="submit" class="btn btn-primary">Save</button>
        <button type="button" class="btn btn-secondary" @onclick="LoadAsync">Load (from local storage)</button>
        <button type="button" class="btn btn-outline-secondary" @onclick="LoadFromServerConfigAsync">Load from appsettings.json</button>
        <button type="button" class="btn btn-danger" @onclick="ResetAsync">Reset</button>
    </div>
</EditForm>

@if (!string.IsNullOrEmpty(StatusMessage))
{
    <div class="mt-3 alert alert-info">@StatusMessage</div>
}

@code {
    private const string StorageKey = "migrationSettings";

    private SettingsModel model = new SettingsModel();
    private string? StatusMessage;

    // 1) Load server config defaults early so values are visible before first render
    protected override void OnInitialized()
    {
        // Read server configuration connection strings as defaults.
        // Use GetConnectionString first (typical pattern), then fallback to Configuration["ConnectionStrings:..."].
        var cfgAccess = Configuration.GetConnectionString("AccessFile") ?? Configuration["ConnectionStrings:AccessFile"];
        var cfgSql = Configuration.GetConnectionString("SqlServer") ?? Configuration["ConnectionStrings:SqlServer"];

        // Only set defaults if config has non-empty values. This prevents assigning null and clobbering existing values later.
        if (!string.IsNullOrWhiteSpace(cfgAccess))
        {
            model.AccessFilePath = cfgAccess;
        }

        if (!string.IsNullOrWhiteSpace(cfgSql))
        {
            model.SqlServerConnectionString = cfgSql;
        }

        // Informational message visible after first render unless local storage overrides it.
        StatusMessage = (model.AccessFilePath is not null || model.SqlServerConnectionString is not null)
            ? "Defaults loaded from server configuration. You can edit or Save to persist locally."
            : "No server defaults found. Enter values and click Save to persist locally.";
    }

    // 2) After first render, try to load saved user settings from localStorage and override defaults if present
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await LoadAsync();
        }
    }

    // Load persisted settings from browser localStorage. If found, override current model and update status.
    private async Task LoadAsync()
    {
        try
        {
            var json = await JS.InvokeAsync<string?>("localStorage.getItem", StorageKey);
            if (!string.IsNullOrWhiteSpace(json))
            {
                var loaded = JsonSerializer.Deserialize<SettingsModel>(json);
                if (loaded is not null)
                {
                    model = loaded;
                    StatusMessage = "Settings loaded from browser storage.";
                    StateHasChanged();
                    return;
                }
            }

            // No saved settings found: keep server defaults (already set in OnInitialized)
            // Update status accordingly (do not overwrite model)
            StatusMessage ??= "No saved settings found; using server defaults (if any).";
            StateHasChanged();
        }
        catch (JSException)
        {
            StatusMessage = "Unable to access browser storage.";
            StateHasChanged();
        }
        catch (Exception ex)
        {
            StatusMessage = $"Error loading settings: {ex.Message}";
            StateHasChanged();
        }
    }

    // Load defaults from server configuration on demand without clearing fields that have existing user input
    private Task LoadFromServerConfigAsync()
    {
        try
        {
            var cfgAccess = Configuration.GetConnectionString("AccessFile") ?? Configuration["ConnectionStrings:AccessFile"];
            var cfgSql = Configuration.GetConnectionString("SqlServer") ?? Configuration["ConnectionStrings:SqlServer"];

            if (string.IsNullOrWhiteSpace(cfgAccess) && string.IsNullOrWhiteSpace(cfgSql))
            {
                StatusMessage = "No defaults found in server configuration (appsettings.json).";
                return Task.CompletedTask;
            }

            // Only overwrite when server config value is present (non-empty) to avoid clearing user's input
            if (!string.IsNullOrWhiteSpace(cfgAccess))
            {
                model.AccessFilePath = cfgAccess;
            }

            if (!string.IsNullOrWhiteSpace(cfgSql))
            {
                model.SqlServerConnectionString = cfgSql;
            }

            StatusMessage = "Defaults loaded from appsettings.json. Edit if needed and click Save to persist locally.";
            StateHasChanged();
            return Task.CompletedTask;
        }
        catch (Exception ex)
        {
            StatusMessage = $"Error loading server defaults: {ex.Message}";
            StateHasChanged();
            return Task.CompletedTask;
        }
    }

    private async Task SaveAsync()
    {
        // Basic validation: require at least one non-empty setting to save
        if (string.IsNullOrWhiteSpace(model.AccessFilePath) && string.IsNullOrWhiteSpace(model.SqlServerConnectionString))
        {
            StatusMessage = "Provide at least one setting before saving.";
            return;
        }

        try
        {
            var json = JsonSerializer.Serialize(model);
            await JS.InvokeVoidAsync("localStorage.setItem", StorageKey, json);
            StatusMessage = "Settings saved to browser storage.";
        }
        catch (JSException)
        {
            StatusMessage = "Unable to access browser storage to save settings.";
        }
        catch (Exception ex)
        {
            StatusMessage = $"Error saving settings: {ex.Message}";
        }

        StateHasChanged();
    }

    private async Task ResetAsync()
    {
        try
        {
            model = new SettingsModel();

            await JS.InvokeVoidAsync("localStorage.removeItem", StorageKey);
            StatusMessage = "Settings reset and removed from storage.";
        }
        catch (JSException)
        {
            StatusMessage = "Unable to access browser storage to remove settings.";
        }
        catch (Exception ex)
        {
            StatusMessage = $"Error resetting settings: {ex.Message}";
        }

        StateHasChanged();
    }

    private class SettingsModel
    {
        public string? AccessFilePath { get; set; }
        public string? SqlServerConnectionString { get; set; }
    }
}
